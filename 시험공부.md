**사용자 증가에 따른 인증 관리** **체계의** **분담을 줄이기 위한 방안을 고안하고** **설계하시오**

 **전제사항** **:** **각 서비스는 고객 증가 또는 인증 서비스의 장애 요인에 영향을 받지 않아야 한다**

**1.** **분산 인증 아키텍처 설계**

  **a)** **마이크로서비스** **기반 인증 서비스**

   **독립적인 인증 서비스**: 인증 서비스를 별도의 마이크로서비스로 분리하여 관리합니다. 이렇게 하면 다른 서비스와 독립적으로 확장 가능하며, 인증 서비스의 장애가 다른 서비스에 영향을 미치지 않는 다

  **b) OAuth2** **및** **OpenID Connect**

​    OAuth2와 OpenID Connect 표준을 기반으로 인증 및 권한 부여를 관리합니다. 이는 인증 서비스의 부하를 줄이고, 사용자 인증을 보다 안전하고 효율적으로 처리할 수 있습니다.



**2.** **토큰 기반 인증 관리**

  **a) JWT (JSON Web Token)** **사용**

   **JWT** **기반 인증**: 인증 후 발급된 JWT 토큰을 사용하여 각 서비스에 접근하도록 합니다. JWT는 서버에 상태를 저장할 필요 없이 사용자의 상태를 관리할 수 있어 서버 부하를 줄일 수 있습니다.

   **토큰의 수명 관리**: 토큰의 만료 시간(Expiration Time)을 설정하여, 토큰이 일정 시간 후에 자동으로 만료되도록 합니다. 이로 인해 재인증 과정을 통해 보안성을 높일 수 있습니다.

  **b)** **리프레시** **토큰**

​    **리프레시** **토큰 사용**: 만료된 JWT 토큰을 갱신하기 위해 리프레시 토큰을 사용합니다. 이는 사용자가 장기간 로그인 상태를 유지하면서도, 보안성을 유지할 수 있도록 돕습니다.



**3.** **캐싱** **및 로드** **밸런싱**

  **a)** **인증 요청** **캐싱**

​    **인증 요청의** **캐싱**: Redis와 같은 인메모리 데이터베이스를 사용하여 최근 인증된 사용자의 세션을 캐싱합니다. 이는 인증 서비스의 부하를 줄이고, 사용자의 인증 속도를 향상시킵니다.

  **b)** **로드** **밸런싱**

​    **로드** **밸런서**: 인증 요청을 여러 인증 서버에 분산시키기 위해 로드 밸런서를 도입합니다. 이는 특정 서버에 부하가 집중되는 것을 방지하고, 시스템의 안정성을 높입니다.



**4.** **장애에 대비한 복구 전략**

  **a)** **다중 인증 서버 구성**

   **다중 인증 서버**: 인증 서비스를 여러 서버에 분산하여 배포합니다. 특정 인증 서버에 장애가 발생하더라도 다른 서버가 이를 대체하여 서비스 연속성을 유지할 수 있습니다.

  **b)** **자동 복구 및 장애 대응**

​    **자동 복구**: 인증 서비스에 장애가 발생하면 자동으로 문제를 감지하고, 복구 작업을 수행하는 시스템을 도입합니다.

​    **서킷** **브레이커**: 인증 서비스에 문제가 발생할 경우, 서킷 브레이커 패턴을 적용하여 요청을 차단하고, 백업 서비스 또는 캐시된 데이터를 사용해 서비스 중단을 최소화합니다.



**5.** **탈중앙화** **인증 방식 도입**

  **a)** **분산** **아이덴티티** **(Decentralized Identity)**

​    **분산** **아이덴티티** **솔루션**: 블록체인 기술을 활용한 분산 아이덴티티 시스템을 도입하여 사용자 인증 데이터를 중앙 서버에 의존하지 않고 분산하여 관리합니다.

​                    이 방식은 특정 서버에 인증 요청이 집중되는 것을 방지하고, 보안성을 향상시킵니다.

  **b)** **페더레이션** **인증**

​    **페더레이션** **인증** **(Federated Authentication)**: 사용자가 한 번 인증되면, 여러 서비스에 접근할 수 있도록 SSO(Single Sign-On)를 구현합니다. 이 방식은 인증 횟수를 줄이고, 사용자 경험을 개선



**6.** **모니터링 및 실시간 대응**

  **a)** **실시간 모니터링**

​    **모니터링 시스템**: Prometheus, Grafana 등을 사용하여 인증 서비스의 상태를 실시간으로 모니터링하고, 이상 상황 발생 시 알림을 통해 빠르게 대응할 수 있도록 합니다.

  **b)** **알림 및 자동 대응 시스템**

​    **자동 대응 시스템**: 장애가 발생했을 때 자동으로 장애를 처리하고, 복구하는 시스템을 도입합니다. 예를 들어, AWS Lambda 등을 활용해 특정 조건이 발생하면 자동으로 새로운 인증 서버를 생성하도록   구성할 수 있습니다.

============================================================================================================================

**MSA** **구조****(MSA)** **의 인증****(Authentication)** **및 인가****(Authorization)**



**OAuth 2.0** **및** **OIDC(OpenID Connect)** **프로토콜**

 이제는 너무나도 익숙한 소셜 로그인은 유저와 기업 모두에게 매력적인 인증 방법입니다. 유저는 간편하게 로그인할 수 있고 기업은 신규 유저의 가입 장벽을 낮추고

 신뢰성 있는 타기업에게 인증의 책임을 미룰 수 있죠. 소셜 로그인 구현을 위해 가장 많이 쓰이고 있는 프로토콜은 OAuth 2.0과 OIDC가 있습니다. 

 이 두 프로토콜이 어떻게 인증 및 인가를 부여하는지 알아봅시다.



 **■** **OAuth 2.0**

  위임 권한부여를 위한 표준 프로토콜인 OAuth는 사용자가 비밀번호를 제공하지 않고 서드파티 어플리케이션에게 접근 권한을 부여할 수 있게 해줍니다. 

  2010년 IETF에서 OAuth 1.0 공식 표준안이 RFC 5849로 발표되었으며, 현재는 OAuth 2.0 (RFC 6749, RFC 6750)이 많이 쓰이고 있습니다.

  ※ 위임 권한부여 (Delegated Authorization) 

​    . 서드파티 어플리케이션이 사용자의 데이터에 접근하도록 허가해 주는 것.

​    . 서드파티에게 아이디/비밀번호를 주기보다는 주로 OAuth를 통해 위임 권한부여를 함.

 **■ 용어 정리**

   OAuth 2.0 의 로직 흐름을 이해하기 위해 몇 가지 용어를 알아야 합니다.



1. Client: 사용자의 데이터에 접근하고 싶어 하는 어플리케이션.
2. Resource Owner: 클라이언트 어플리케이션이 접근하길 원하는 데이터의 사용자 또는 소유자.
3. Resource Server: 클라이언트 어플리케이션이 접근하길 원하는 데이터를 저장하고 있는 서버.
4. Authorization Server: 사용자로부터 권한을 부여받아 클라이언트가 사용자의 데이터에 접근할 권한을 부여해 주는 권한부여 서버.
5. Access Token: 리소스 서버의 사용자 데이터에 접근하기 위해 클라이언트가 사용할 수 있는 유일한 키



 **■** **OAuth 2.0** **요청을 위한** **파라미터**

   Client가 Authorization Server에 요청을 보낼 때 주로 다음과 같은 설정값을 Query String을 통해 전달합니다.



1. response_type: Authorization Server로부터 받길 원하는 응답의 타입 (code, token 등).
2. scope: Client가 Resource Server에서 접근하고 싶은 리소스 리스트
3. client_id: OAuth 세팅을 할 때, Authorization Server에 의해 제공. Client가 누구인지 알아내기 위해 사용.
4. client_secret: Authorization Server에 의해 제공. Code와 client_secret을 가지고 Access Token 받게 됨. 
5. redirect_url: Authorization Server에게 OAuth 플로우가 끝나면 어디로 보내줄지에 대해 알려주는 역할

============================================================================================================================

**MSA** **구조****(MSA)** **의 인증****(Authentication)** **및 인가****(Authorization)**



 **■ 인증방식과 동작 흐름** 



  **1****.** **권한 부여 코드 승인 방식** **(Authorization Code Grant)**

​    자체 생성한 Authorization Code를 전달하는 방식으로 OAuth2.0에서 가장 기본이 되는 방식.

​    response_type=code, grant_type=authoration_code 등 형식으로 요청.

​    Authoration Server가 Redirect 시 엑세스 토큰을 전달하면 브라우저에 토큰이 바로 노출되기 때문에

​     프론트앤드에서 code를 받아서 서버로 전달하면 서버에서 엑세스 토큰을 요청하는 방식.

​    Code를 Access Token으로 변환할 때 client_secret이 필요. 결국, 백엔드 서버에서만 필요.

​    백엔드 사이에서만 토큰이 이동하여 비교적 안전한 방식

![image-20240811230631274](C:\Users\redmars\AppData\Roaming\Typora\typora-user-images\image-20240811230631274.png)
   **2.** **암묵적** **승인 방식** **(Implicit Grant)**

​    자격 증명을 안전하게 저장하기 힘든 클라이언트 사이드에서 OAuth2.0 인증에 최적화된 방식.

​    response_type=token 등 형식으로 요청.

​    Autorization Code 발급 없이 바로 Access Token 발급되기 때문에 만료 기간이 짧아야 함.

​    절차가 비교적 간단하지만 Access Token이 URI를 통해 전달되어 보안에 취약

![image-20240811230655727](C:\Users\redmars\AppData\Roaming\Typora\typora-user-images\image-20240811230655727.png)

   **3****.** **자원 소유자 자격 증명 방식** **(Resource Owner Password Credentials Grant)**

​     Authorization Server, Resource Server, Client가 모두 같은 시스템에 속해 있을 때만 사용 가능.
​     ID, Password로만 Access Token을 발급받는 방식. 

​     grant_type=password 형식으로 요청

![image-20240811230715230](C:\Users\redmars\AppData\Roaming\Typora\typora-user-images\image-20240811230715230.png)

   **4.****클라이언트** **자격 증명 방식** **(Client Credentials Grant)**

​    클라이언트의 자격 증명만으로 Access Token을 획득하는 방식.
​     User가 아닌 Client에 대한 인가가 필요할 때 사용.
​     즉, Client에 대해 리소스 접근 권한이 설정된 경우 사용.
​     자격 증명을 안전하게 보관할 수 있는 클라이언트에서만 사용.

![image-20240811230719647](C:\Users\redmars\AppData\Roaming\Typora\typora-user-images\image-20240811230719647.png)

============================================================================================================================

**MSA** **구조****(MSA)** **의 인증****(Authentication)** **및 인가****(Authorization)**



 **■** **OpenID Connect** **프로토콜**

   OIDC는 OAuth 2.0을 기반으로 만들어진 유저의 인증(Authentication)을 위한 프로토콜 입니다. 

   OIDC는 OAuth 2.0을 확장하여 인증 방식을 표준화 합니다. 

   OpenID를 관리하는 OpenID Foundation에서 정의한 OpenID의 개념은 다음과 같습니다.

​      

   OpenID Connect 1.0은 OAuth 2.0 프로토콜 위에서 동작하는 간단한 ID 레이어입니다. 

   이를 통해 클라이언트는 인증 서버에서 수행한 인증을 기반으로 최종 사용자의 신원을 확인할 수 있을 뿐만 

   아니라, 최종 사용자에 대한 기본 프로필 정보를 상호 운용 가능하며 REST와 유사한 방식으로 얻을 수 있습니다.

   OpenID Connect를 사용하면 웹 기반, 모바일, 자바스크립트 클라이언트 등을 포함한 모든 유형의 클라이언트에서

   인증 세션과 최종 사용자에 대한 정보를 요청하고 받을 수 있습니다. 스펙은 확장 가능하므로 필요에 따라 참가자들에게 ID 데이터 암호화, OpenID 제공자 확인, 로그아웃

   등을 이용할 수 있습니다.

![image-20240811230745006](C:\Users\redmars\AppData\Roaming\Typora\typora-user-images\image-20240811230745006.png)

 **■ 인증 방식과 동작 흐름**

   기존 Oauth 2.0의 동작 흐름과 거의 유사하며 ID token을 추가 발급한다는 차이점이 있습니다.

   추가로, OpenID 문서를 읽다 보면 IDP, RP라는 용어가 등장하는데 각각 다음과 같습니다.

​    \- IDP (IDentity Provider): Google, Apple 같은 간편 로그인 서비스 제공사 (OpenID 제공자)

​    \- RP (Relying Party): 사용자를 인증하기 위해 IDP에 의존하는 주체 (어플리케이션)

![image-20240811230750682](C:\Users\redmars\AppData\Roaming\Typora\typora-user-images\image-20240811230750682.png)

 **■** **OAuth** **2.0** **과** **OIDC****의 차이점**

  **1****.** **스코프** **(Scopes)**

​    OAuth 2.0에서는 제공자가 원하는 대로 요청 범위를 설정 가능하여 유연한 사용이 가능했지만 상호 운용에 

​    취약했습니다. OIDC는 요청범위를 profile, email, address, phone으로 표준화했습니다.
   **2****.** **클레임** **(claims)**

​    OIDC에서 ID토큰의 payload는 claims라고 알려진 필드들을 포함합니다. OIDC는 이런 클레임들을 표준화했습니다.

​    1. iss: 토큰 발행자, 2. sub: 사용자의 유니크한 식별자, 3. email: 사용자 이메일, 4.iat: 토큰 발행 시간 (Unix time), 5.exp: 토큰 만료 시간(Unix time)


   **3****.** **사용자 정보 요청** **엔드포인트** **통일**

​     OIDC는 사용자가 요청하는 엔드포인트도 표준화했습니다. 예를 들어 /userinfo를 통해 사용자 메타데이터 정보를 검증합니다.

   **4****. ID token**

​    OIDC의 동작 흐름에서 가장 눈에 띄는 차이가 ID token의 유무입니다. ID token은 JWT로 생성이 되어 Payload 내부에 클레임을 포함합니다.

​    즉, ID token을 복호화하여 사용자 정보를 얻을 수 있습니다. OAuth 2.0에서 액세스 토큰을 얻고 다시 사용자 정보를 요청하는 것보다 네트워크 통신 비용이 절감됩니다.



  ※ OAuth2: 인가 프로토콜로서, 인증된 사용자에게 자원 접근 권한을 부여하는 것에 중점을 둡니다.

  ※ OIDC: OAuth 2.0을 확장하여, 사용자의 인증 정보를 안전하게 전달하는 인증 프로토콜입니다.

============================================================================================================================

**MSA** **구조****(MSA)** **의 인증****(Authentication)** **및 인가****(Authorization)**



**Stateless** **한 프로토콜** **: HTTP**

 우선 HTTP의 프로토콜 상태에 알아보자. HTTP 는 stateless 한 특성 때문에 각 통신의 상태는 저장되지 않는다. 하지만 서비스에서는 어떤 유저가 기능을 사용하는지

 특정할 수 있어야 하는데 이를 위해서 세션(Session) 혹은 토큰(Token)이 사용된다.

 유저가 로그 인을 시도할 때 서버 상에서 일치하는 유저 정보를 찾았다면 인증 확인의 표시로 세션이나 토큰을 발급해준다.

 세션과 토큰의 가장 큰 차이점은 세션은 서버에 저장된다는 것이고, 토큰은 클라이언트 측에서만 저장된다는 것이다.



**쿠키****(Cookie) +** **세션****(Session)**

 쿠키에 ID, PW와 같은 중요한 정보가 아닌, 인증을 위한 별개의 정보를 세션 저장소에 저장하고, 클라이언트는 세션을 쿠키에 담아 서버에 요청한다. 

 서버는 세션 저장소에 있는 세션과 일치하는지 즉, 유효한 세션인지 확인 후 적절한 응답을 보내준다.

 

**■ 동작과정**

1. 클라이언트가 ID/PW로 서버에 로그인
2. ID/PW로 인증 후, 사용자를 식별한 특정 유니크한 세션 ID를 만들어 마치 자물쇠처럼 서버의 세션 저장소에 저장 
3. 세션 ID를 특정한 형태로 클라이언트에 다시 반환
4. 이후 사용자 인증이 필요한 정보를 요청할 때마다 세션 ID를 쿠키에 담아 서버에 함께 전달
5. 인증이 필요한 API일 경우, 서버는 세션 ID가 세션 저장소에 저장된 것인지 즉 유효한 세션인지 확인

   유효한 세션이라면, 인증 완료 후 적절한 응답을 보내준다. 없다면 401 에러 반환



**■ 문제점**

1. 세션 ID, Cookie 등이 탈취된다면 세션 저장소를 전부 지워 해결 가능하지만, 탈취당하지 않은 정상적인 사용자도 모두 재 인증을

​    해야하는 상황이 발생한다.

2. 무엇보다 HTTP의 가장 큰 특성 중 하나인 stateless한 특성을 위배하게 된다. stateless 특성은 서버에서는 클라이언트의 상태를

​    저장하지 않아야 하지만 세션 저장소라는 곳에서 클라이언트의 상태를 저장하게 되므로 stateful 한 상태가 된다. 

​     \- 위의 내용이 문제가 되는 이유는 확장성에 있다. 1번 서버에서 로그인한 사용자가 다른 2번 서버로 요청하게 되면 

​      2번 서버에서는 세션이 저장되어 있지 않아 유효하지 않은 세션으로 인식된다는 것이다.

​     \- 이런 문제를 해결하기 위해 세션 저장소를 별도로 외부에 두는 것이 가장 일반적인 방식이다. Redis가 세션 저장소로 사용



**■ 다중 서버환경에서 세션 불일치 문제점 해결 방안**

1. 세션 클러스터링 (Session Clustering)

   세션 클러스터링으로 서버 간 로그인 정보가 담긴 세션을 공유하는 방법이 있지만, 실제 서비스와 관련없는 인프라적인 작업으로

   서버 리소스를 많이 쓰게되는 단점이 있다.

   전체적인 서버 규모가 크지 않다면 나쁘지 않지만, MSA로 잘게 쪼개져 수십 수백개의 서버로 이루어진다면 단점이 극명하게 나타날 것이다.

   세션 클러스터링에는 방법이 여러 가지다. "WAS 구성", "외부에 세션 서버 구축", 

![image-20240811230850279](C:\Users\redmars\AppData\Roaming\Typora\typora-user-images\image-20240811230850279.png)

**■** **스티키** **세션** **(Sticky Session)**

  스케일 아웃 시 여러 서버에 세션 정보를 복사할 필요 없도록 특정 세션을 처음 처리한 서버에게 이후 같은 세션의 요청을 같은 서버가 처리하도록 하는 방식이다.

  A 사용자가 A 서버에게 요청했다면, A사용자의 요청은 모두 A서버에서 처리하는 방식이다. 이 방법의 문제점은 각 서버가 균일하게 요청을 처리할 수 없다는 점에 있다.

  즉, 특정 서버에만 요청이 몰리는 상황이 발생할 수 있다. 부하가 균일하게 분산되지 않는다.



**■ 세션 스토리지 분리**

  이 방식은 세션 스토리지를 외부 서버로 분리하는 방식이다. 이 때 사용되는 세션 스토리지 서버로 일반적인 Disk-Based DB (Mysql, PostgreSQL, MongoDB 등)을

  사용할 수 있지만, 입출력이 잦은 세션 특성 상 I/O 성능이 느린 데이터베이스는 사용하기에 적합하지 않다. 따라서 세션을 저장하는 저장소로는 In-Memory DB를 사용하는

  것이 일반적이다. In-Memory DB 중 어떤 DBMS 를 사용하는 것이 좋을까? 세션 데이터는 Key-Value로 구성되어 있다. 

  따라서 세션을 저장할 때는 대표적인 Key-Value DB인 Redis와 Memcached 를 사용한다.



**토큰** **JWT(****Json** **web token)**

 JWT 토큰 방식은 웹표준(RFC 7519)로서 두 개체에서 JSON 객체를 사용하여 가볍고 자가수용적인(self-contained) 방식으로 

 정보를 안정성 있게 전달한다. (자가수용적이라는 의미는 JWT 안에 인증에 필요한 모든 정보를 자체적으로 지니고 있다



**■ 동작과정**

1. 사용자는 클라이언트에서 ID/PW를 통해 로그인을 요청한다.
2. 유효한 ID/PW라면, Access token & Refresh token을 발급한다.
3. 클라이언트는 전달 받은 토큰들은 localStorage에 저장한다.
4. 클라이언트는 헤더에 Access token을 담아 서버에 요청한다.
5. 서버에서는 Access token을 검증하고, 응답을 클라이언트로 보낸다.

​    \- Access token이 유효하지 않다면 Refersh token으로 Access token을 재발급한 뒤, access token을 리턴해준다.

![image-20240811230940571](C:\Users\redmars\AppData\Roaming\Typora\typora-user-images\image-20240811230940571.png)

**■** **JWT** **구조**

1. 헤더 (Header) : 헤더는 두 가지 정보를 가진다. “typ - 토큰의 타입(JWT)” , “alg - 해싱 알고리즘” (Signature 를 해싱하기 위한 알고리즘 지정)
2. 내용 (Payload) : Payload에는 토큰에 담을 정보들이 존재하고, 여기에 담는 정보의 한 조각을 클레임(claim) 이라고 한다.

​    \- 클레임은 키 값 형태로 존재한다. 클레임의 종류는 등록된(registered) 클레임, 공개(public) 클레임, 비공개(private) 클레임들이 있다.

3. 서명 (Signature) : Signature 이란 토큰을 인코딩 하거나 유효성 검증을 할 때 사용하는 고유한 암호화 코드이다.

​    \- 서명 생성 과정

​      . 헤더와 페이로드 값을 각각 BASE64 로 인코딩

​      . 위에서 인코딩한 값을 비밀 키를 이용해 헤더에서 정의한 알고리즘으로 해싱

​      . 위에서 해싱한 값을 다시 BASE64 로 인코딩

![image-20240811230945388](C:\Users\redmars\AppData\Roaming\Typora\typora-user-images\image-20240811230945388.png)

**■** **JWT** **의 장점**

1. 인증에 필요한 정보가 토큰에 있기에 별도의 저장소가 필요 없다.

​    \- 하지만, 보안성을 높이기 위해 Refresh Token을 사용하는 경우 별도의 저장소에 저장하면서 사용하는 경우도 있긴 하다.

2. Cookie와 Session 사용 시 문제점이었던 stateful 한 특성을 JWT 토큰 사용 시에는 stateless 하게 가져갈 수 있다. 즉, 서버는 클라이언트의 상태를 가질 필요가 없다.
3. HTTP 헤더에 넣어서 쉽게 전달 가능하다.
4. 확장성에 용이하다. MSA 환경에 적용하기 편하다.



■ JWT의 단점

1. 거의 모든 요청에 토큰이 포함되므로 트래픽 크기에 영향을 미칠 수 있다.
2. 토큰에 정보가 많아져 토큰의 크기가 커지면 네트워크에 부하를 줄 수 있다.
3. 페이로드는 암호화된 게 아니라 BASE64 로 인코딩된 것이므로, 중간에 토큰을 탈취하면 페이로드의 데이터를 모두 볼 수 있다.
4. 따라서 페이로드에는 중요 정보를 담아선 안된다.



■ JWT의 암호화 방식

  JWT 토큰 생성 시, JWT 헤더와 페이로드 정보를 인코딩하고, 둘을 합친 문자열을 비밀 키로 서명한다. 

  이 때 대칭키 암호화, 비대칭키 암호화 방식을 사용할 수 있다.

![image-20240811231004052](C:\Users\redmars\AppData\Roaming\Typora\typora-user-images\image-20240811231004052.png)

  **대칭키 암호화** **-** 암호화, 복호화 키가 같으면 대칭키 암호화 방식이라고 한다.

   . 같은 키를 사용해 암호화, 복호화를 수행하기 때문에 속도가 빠르다.

   . 대표적으로 HMAC 암호화 알고리즘이 있다.

   . HS256, HS384, HS512 .... 가 이에 해당하고, 뒤 숫자는 secret key의 최소 바이트 크기를 의미한다.

   . 기본적으로 단방향 암호화 알고리즘인 SHA-256 과 함께 쓰인다.

   . 값에 SHA-256를 적용해서 해싱 후 private key( == secret key , 대칭키 역할)로 암호화 한다.

   . private key를 알고있는 서버만 Signature 유효성 검증이 가능하다. 즉 JWT를 복호화 할 수 있다.



  **비대칭키** **암호화** **-** 암호화, 복호화 키가 다르면 비대칭키 암호화 방식이라고 한다.

   . 다른 키를 사용해 암호화, 복호화를 수행하기 때문에 속도가 느리지만, 대칭키 암호화에 비해 안전하다.

   . 대표적으로 RSA 암호화 알고리즘이 있다.

   . 마찬가지로, SHA-256 단방향 암호화 알고리즘과 함께 쓰인다.

   . 값에 SHA-256 을 적용해서 해싱 후 비밀키(private key)로 암호화한다.

​    그리고 공개키(public key) 는 공개적으로 제공한다. 어떠한 서버든 이 공개키를 통해 JWT를 복호화할 수 있다.

  **대칭키 암호화** **vs** **비대칭키** **암호화**

​    대칭키 암호화 방식 같은 경우, private key를 모르는 서버는 JWT의 유효성을 검증할 수 없다. 

​    반대로 비대칭키 암호화 방식은 private key를 몰라도 public key를 통해 복화 할 수 있기 때문에 JWT의 유효성을 검증할 수 있다.



  **대칭키 암호화 방식에서의 인증서버 구축하기**

1. 인증 서버가 클라이언트에게 JWT를 발급
2. 클라이언트는 JWT와 함께 애플리케이션 서버에 요청
3. 애플리케이션 서버는 인증 서버의 private key를 모르므로 JWT를 검증할 수 없음

​    각 애플리케이션 서버에 인증서버의 private key를 넣어놓으면 되긴 한다. 

​    하지만 MSA 환경에서 수많은 애플리케이션 서버가 존재하는데, scale-out 할때마다 매번 private key를 넣어줘야 한다.



  **비대칭키** **암호화 방식에서의 인증서버 구축하기**

1. 인증 서버가 클라이언트에게 JWT를 발급
2. 클라이언트는 JWT와 함께 애플리케이션 서버에 요청
3. 애플리케이션 서버는 인증 서버의 public Key를 통해 JWT를 검증할 수 있음

​    각 애플리케이션 서버에 일일히 key를 넣어줄 필요가 없다. public key가 공개되어 있기 때문이다.



  **API Gateway****가 존재한다면****?**

  비대칭키 암호화 방식을 사용하면 매번 각 서버에서 필터나 인터셉터를 통해 JWT에 대한 검증을 수행할 것이다

  하지만 API Gateway가 존재하면 API GW에서만 검증하면 된다. 

  API GW에서 public key를 통해 검증해도 되지만, 대칭키 방식을 사용해도 API GW에만 private key를 넣어주면 되므로 대칭키 방식의 문제점도 딱히 드러나지 않는다.



  간단히 결론을 내려보면 **API GW****가 없다면** **비대칭키** **암호화 방식을** **사용하는게** **좋고****, API GW****가 존재한다면 어떤 방식을 쓰든 상관없을** 것 같다는 생각이 든다.



![image-20240811231031969](C:\Users\redmars\AppData\Roaming\Typora\typora-user-images\image-20240811231031969.png)

**■** **Refresh Token**

  Refresh Token은 토큰이 탈취당할 경우를 대비해 사용되는 것이다. Access Token 만으로 공격자가 요청하는 것인지

   정상적인 클라이언트가 요청하는 것인지 알 수 없기 때문이다. Access Token은 언제든지 탈취될 수 있다고 가정하기

   때문에 Access Token에는 중요한 정보를 담으면 안된다. 따라서 Access Token의 유효기간을 짧게 설정하고, 

  Refresh Token의 유효기간을 길게 설정한다. 물론 Access Token의 유효기간 동안에는 공격에 노출되어 있지만, 

  피해를 최소화하기 위한 방법이다.



**■ 동작과정**

1. Access Token이 탈취됐을 때 대비를 위해 Refresh Token 개념을 도입했다. 그런데 Access Token과 

​    Refresh Token 모두 클라이언트에 저장되면 같이 탈취되는거 아닌가? 라는 생각이든다.

2. 그래서 Access Token을 로컬 스토리지 또는 세션 스토리지에 저장하고, Refresh Token은 쿠키에 저장하고 

​    보안 옵션들(HTTP Only, Secure Cookies)을 활성화 한다.

3. 물론 Refresh Token은 서버에도 저장돼있어야 한다.



**■** **Refresh Token****만 탈취되면****?**

1. 공격자는 탈취한 Refresh Token 으로 계속 Access Token을 생성해서 정상적인 사용자처럼 서버에 계속 요청할 수 있다.
2. 이를 대비해서 서버에서 추가 검증 로직으로 방어해야 한다.

​    \- DB에 사용자와 Access Token, Refresh Token 들을 매핑하여 저장한다.

​    \- 정상적인 유저의 Access Token이 만료된 경우

​    \- Access Token과 Refresh Token을 서버로 보내서 새 Access Token을 요청한다 → 서버에서는 DB에 저장된Access Token, Refresh Token쌍과 클라이언트에서 보낸

​      토큰 쌍들을 비교한다 → 일치하면 새 Access Token토큰을 발급해준다.

​    \- 공격자가 Refresh Toekn을 탈취한 경우

​     . 공격자가 탈취한 Refresh Token으로 새 Access Token 생성 요청 → Access Token이 없이 요청하면 공격으로 간주 → 서버에서 Access Token , Refresh Token 폐기

**■** **JWT** **와** **Session** **방식** **비교**

  **1.** **사이즈**

​    세션의 경우, Cookie 헤더에 세션 ID만 실어 보내면 되므로, 트래픽을 적게 사용한다. 하지만, JWT는 사용자 인증 정보와 토큰의 발급시각, 만료시각, 토큰의 ID 등 

​    담겨 있는 정보가 세션 ID에 비해 비대하므로 세션 방식보다 훨씬 더 많은 네트워크 트래픽을 사용한다.

​    그에 비해 세션 ID는 단 6바이트. 50배가 넘는 트래픽 비효율이다.

  **2.** **안정성과** **보안성**

​    . 세션의 경우, 모든 인증 정보를 서버에서 관리하기 때문에 보안 측면에서 조금 더 유리하다. 설령 세션 ID가 해커에게 탈취된다고 하더라도, 

​     서버 측에서 해당 세션을 무효 처리하면 된다.

​    . 토큰의 경우는 그렇지 않다. 토큰은 서버가 트래킹하지 않고, 클라이언트가 모든 인증정보를 가지고 있다. 따라서 토큰이 한 번 해커에게 탈취당하면 

​     세션과 비교했을 때 조금 복잡한 방식(위의 내용 참고)으로 해킹을 막아야한다.

​    . 또한 JWT 특성 상 토큰에 실린 Payload가 별도로 암호화 되어있지 않으므로, 누구나 내용을 확인할 수 있다. 따라서 Payload에는 민감한 데이터를 실을 수 없다. 

​    . 하지만 세션과 같은 경우에는 모든 데이터가 서버에 저장되기 때문에 아무나 함부로 열람할 수 없기에 저장할 수 있는 데이터에 제한이 없다.

  **3.** **확장성**

​    . 그럼에도 불구하고 최근 모던 웹 어플리케이션이 토큰 기반 인증을 사용하는 이유가 바로 이 확장성이다.

​    . 일반적으로 웹 어플리케이션의 서버 확장 방식은 수평 확장을 사용한다. 즉, 한 대가 아닌 여러 대의 서버가 요청을 처리하게 된다.

​     이때 별도의 작업을 해주지 않는다면, 세션 기반 인증 방식은 세션 불일치 문제를 겪게 된다. 

​     이를 해결하기 위해서 Sticky Session, Session Clustering, 세션 스토리지 외부 분리 등의 작업을 해주어야 한다.

​    . 하지만, 토큰 기반 인증 방식의 경우 서버가 직접 인증 방식을 저장하지 않고, 클라이언트가 저장하는 방식을 취하기 때문에 

​     이런 세션 불일치 문제로부터 자유롭다. 이런 특징으로 토큰 기반 인증 방식은 HTTP의 비상태성(Stateless)를 그대로 활용할 수 있고, 따라서 높은 확장성을 가질 수 있다.

  **4.** **서버 부담**

​    . 확장성과 어느 정도 이어지는 내용이다. 세션 기반 인증 방식은 서비스가 세션 데이터를 직접 저장하고, 관리한다. 따라서 세션 데이터의 양이 많아지면 많아질수록 

​    서버의 부담이 증가할 것 이다.

​    . 하지만 토큰 기반 인증 방식은 서버 대신, 클라이언트가 인증 데이터를 직접 가지고 있다. 따라서 유저의 수가 얼마나 되던 서버의 부담이 증가하지 않는다. 

​     따라서 서버의 부담 측면에서는 세션 기반 인증 방식보다는 토큰 기반 인증 방식이 조금 더 유리함을 알 수 있다.

  **4.** **Session** **과** **Token** **의 차이점** **정리**

​    stateful과 stateless 하다는 측면에서 차이점이 존재한다. 이는 토큰이 탈취됐을 때, 서버에서 능동적으로 이에 대응하여 토큰을 폐기 처리할 수 있냐 없느냐에 따라 직결

​    Session 방식은 로그인한 유저의 세션 개수를 제한할 수 있다는 점에서도 차이가 있다.

​    JWT의 등장 배경을 살펴보면, 보안이 뛰어나서가 아니라, 마이크로 서비스 아키텍처(MSA)가 도입되면서 주목 받기 시작한 방식이다.

​    아래 사진처럼 수천 수만가지의 서버 to 서버 통신이 이루어지는 아키텍처에서 중앙화된 사용자 식별 저장소를 통해 각 API 요청을 인증처리 해야한다면.. 인증 서버만 

​    수백대가 필요할 것이다. 그렇다고 아무리 내부 서버 끼리의 통신이라고 인증을 제외할 순 없으니 JWT를 통해 인증을 진행하는 것이다.

​    추가로 앱과 웹을 모두 서비스하는 서버인 경우 웹에서는 Session을 이용하고 앱에서는 토큰을 이용하는 방식으로 별개의 인증방식을 가져가는게 아니라, 

​    두 환경 모두 토큰을 기반으로 인증하여 환경에 구애받지 않고 동일한 API를 이용할 수 있다.

============================================================================================================================

**■** **토근** **기반 인증 절차**

1. 서비스 사용자는 자신의 신원을 증명하기 위해 인증 서비스로부터 토큰을 발급 받는 다.
2. 사용자는 발급받은 토큰을 서비스 요청 명령에 첨부하여 서비스에게 전달 한다.
3. 명령을 수신한 서비스는 첨부된 토큰을 확인하여 인증 절차를 수행하고 사용자인증정보 확인

![image-20240811231109916](C:\Users\redmars\AppData\Roaming\Typora\typora-user-images\image-20240811231109916.png)

**■** **엑세스****(Access Token)** **인증**

  엑세스 토큰은 사용자를 특정하기 위해 인증 서비스가 랜덤하게 생성된 고유 식별자로, 

  엑세스 토큰 자체로는 어떠한 정보도 담고 있지 않다. 

  그러나 인증 서비스는 토큰 발급 시 생성된 엑세스 토큰과 사용자 인증 정보를

   매핑하여 저장함으로써 엑세스 토큰을 key 로 하여 사용자의 인증 정보를 확인 할 수 있다.



  **엑세스** **토큰 인증 절차**

1. 사용자는 엑세스 토큰을 첨부하여 서비스에게 명령을 요청한다.
2. 서비스는 엑세스 토큰을 인증 서비스에게 전달하여 사용자 인증 정보 확인 요청한다.
3. 인증 서비스는 수신된 엑세스 토큰에 매핑된 사용자 인증 정보를 서비스에게 전달한다.
4. 서비스는 인증 서비스로부터 전달받은 사용자 인증 정보를 기반으로 요청을 처리한다.



  서비스는 요청된 모든 명령 처리를 위해 인증 서비스에 질의 해야하며 그에 따라

  강한 의존성을 갖게 된다. 이러한 상황에서 인증 서비스에 장애가 발생한다면 

  전체 서비스로 장애가 전파 될 것 이다.



**■** **JWT(****Json** **Web Token)** **인증**

  엑세스 토큰과 다르게 JWT 는 토큰 스스로가 사용자 인증 정보를 갖고 있다. 인증 서비스는 

  토큰 발급 시 Base64 로 인코딩된 Json 형식의 사용자 인증 정보와 해당 인증 정보의 위변조

  검증을 위한 시그니처(Signiture) 를 토큰에 첨부하여 함께 제공한다. 첨부된 시그니처는 인증

  서비스가 발급한 공개키(public key) 를 통해 검증 가능하다.

  

  JWT 시그니처 검증 목적은 사용자 인증 정보 해석이 아닌 첨부된 인증 정보의 위변조가 없음을

  확인하기 위함이다. 사용자 인증 정보는 Base64 를 통해 쉽게 decode 가능하기 때문에 사용자의

  개인정보 등 보안이 필요한 성격의 정보는 JWT 에 포함하면 안된다.



  JWT 검증 절차

1. 사용자는 JWT를 첨부하여 서비스에게 명령을 요청한다.
2. 서비스는 미리 발급받은 공개키를 사용해 JWP 의 유효성을 검증한다.
3. 서비스는 유효성이 검증된 JWT 를 Base64 를 이용하여 사용자 인증 정보를 디코드한다.
4. 서비스는 디코드된 사용자 인증 정보를 기반으로 요청 처리한다.

![image-20240811231136407](C:\Users\redmars\AppData\Roaming\Typora\typora-user-images\image-20240811231136407.png)

  토큰 스스로가 사용자 정보를 포함하고 있어 서비스들은 인증 서비스와 별도의 의존성을

  갖지 않게 되었다. 반면 이러한 특성으로 발생할 수 있는 문제점 또한 있다.

  ![image-20240811231142587](C:\Users\redmars\AppData\Roaming\Typora\typora-user-images\image-20240811231142587.png)

  JWT 문제점

  발급된 토큰 관리의 어려움, 엑세스 토큰의 경우 중앙에서 관리하여 각 서비스들이

  인증 서비스에 질의해야 하는 반면, JWT 는 한 번 발급된 토큰은 분산되어 의존성

  없이 스스로 인증되기 때문에 관리에 어려움이 있다.



1. 접근제어

​    엑세스 토큰은 인증 서비스가 저장된 토큰 정보를 삭제해서 토큰 사용을

​    불가능하게 하지만, JWT 는 토큰에 명시된 만료 시간 전까지는 제어가 불가능하다.

2. 변경된 정보 적용 

​    엑세스 토큰은 토큰에 매핑된 정보를 수정하여 즉시 변경 적용이 가능하지만

​    JWT 는 접근제어와 마찬가지로 JWT 에 명시된 만료 시간 전까지 잘못된 정보로

​    서비스에 접근할 수 있다. 

  

  이러한 관리의 어려움으로 JWT 는 가능한 토큰 만료 시간을 짧게 가져가는 것이 좋다

  토큰 만료 시간이 짧아 질수록 토큰 갱신을 위해 발생되는 비용이 커지게 되서

  적절한 시간 선택이 필요하다



**■** **API Gateway****를 활용한 공통 인증**

  MSA에서 API Gateway는 여러 분리된 서비스 환경에서 사용자에게 하나의 엔드포인트를 제공하기 위해

  사용되는 패턴이다. API Gateway는 서비스 최전방에 위치하며, 모든 사용자 요청은 API Gateway를 통해서만 

  각 서비스에 접근 가능하게 된다. 따라서 API Gateway는 서비스 전체에 미들웨어 계층으로써 공통된 로직을

  처리할 수 있으며 인증도 API Gateway가 처리할 수 있는 공통 로직 중 하나이다.

![image-20240811231159955](C:\Users\redmars\AppData\Roaming\Typora\typora-user-images\image-20240811231159955.png)

  API Gateway 인증 절차

1. 사용자는 JWT를 첨부하여 API Gateway를 통해 서비스에게 명령을 요청한다.
2. API Gateway는 요청된 명령을 수신하여 JWT 인증 로직을 수행한다.
3. 인증된 사용자 정보를 요청에 추가로 첨부하여 뒷단 서비스에게 전달한다.
4. 서비스는 API Gateway가 첨부한 사용자 인증 정보를 기반으로 요청을 처리한다.



  앞 단에 API Gateway가 공통된 인증 절차를 수행하면서 뒷단의 서비스들은 인증 방식 으로 부터

  완전히 독립되어 인증 서비스와 의존성이 사라지게 되었다. 이후 인증 절차에 어떠한 변화에도 다른 서비스들은

  영향이 없을 것이다. 예를 들어 JWT의 인증 방식이 앞서 설명한 엑세스 토큰으로 변경되어도 API Gateway가

  동일한 사용자 인증 정보를 반환할 수 있다면 뒷 단의 다른 서비스들은 어떠한 변경 사항도 없을 것이다.

  

   모든 서비스의 요청은 API Gateway를 통해 각 서비스에 전달된다. 이러한 구조로 API Gateway는 API Gateway 

   하나의 장애로 서비스 전체가 먹통이 되는 SPOF(Single Point of Failure)가 될 수 있다. 이러한 상황을 대비하기 위해 

   API Gateway 도입 시에는 철저한 이중화가 준비되어야 한다. 



**■ 인증 캐시**

  토큰을 이용한 사용자 인증 결과는 가변성이 크지 않은 데이터이다. 방금 막 유효성이 확인된 토큰이 다음 요청에 결과가 변경되어 있을 가능성을 크지 않다.  

  이러한 데이터 성격으로 토큰을 키로 하여 사용자 인증 데이터를 캐시 하여 재사용할 수 있다.

  재사용된 캐시 데이터는 아래의 이점을 갖는다.



1. 통신 오버해드 감소 

   캐시 데이터를 재사용함으로써 반복되는 인증 오버해드(엑세스 토큰: 통신 오버해드, JWT: 시그니처 검증 연산 오버해드)를 줄일 수 있다.

2. 장애 전파 최소화 

   인증 서비스 장애 발생 시에도 캐시 데이터를 사용함으로써 장애 영향도를 최소화할 수 있다.

   그러나 캐시의 사용은 상황에 따라 이미 내용이 변경되어 유효하지 않은 데이터를 참조 할 수도 있음을 뜻한다. 

   따라서 각 서비스 성격과 정책에 따라 알맞는 캐시 만료 시간이 설정되어야 하며, 

   일부 인증의 유효성 판단이 크리티컬(Critical)한 경우, 캐시 사용을 배제해야 한다.

**■ 결론**

  지금까지 MSA 에서 사용될 수 있는 사용자 인증 전략을 살펴 보았다.

  소개된 전략의 핵심은 서비스 전반으로 사용될 인증 서비스 기능과 다른 서비스의 의존성을 줄이는 것이다. 
   앞서 설명한 내용을 요약하면 아래와 같다.



  JWT 를 적용하여 인증 서비스와 의존성 없이 각 서비스가 스스로 사용자 인증을 수행할 수 있도록 하자



  API Gateway 에서 공통 인증 절차를 수행하여 각 서비스와 인증 절차를 추상화 하자.



  인증캐시를 사용하여 반복된 인증 절차를 줄이자.

============================================================================================================================

**B2B** **고객을 위한 제로 트러스트 인증 방식에 대한 프로세스를 설계하시오**

제로 트러스트(Zero Trust) 인증 방식은 "절대 신뢰하지 말고 항상 검증하라"는 원칙에 기반하여 보안을 강화하는 접근 방식입니다. 

이는 특히 B2B 환경에서 중요한 데이터와 시스템을 보호하는 데 매우 효과적입니다. 

**1.** **사용자 및 기기 식별**

  **-** **다중 인증****(Multi-Factor Authentication, MFA)**:

   사용자는 비밀번호 외에도 추가적인 인증 요소를 통해 본인임을 증명해야 합니다. 예를 들어, OTP(One-Time Password), 생체 인식(지문, 얼굴 인식), 인증 앱 등을 활용합니

  **-** **기기 인증****(Device Authentication)**:

   사용자가 접근하는 기기가 사전 등록된 신뢰할 수 있는 기기인지 확인합니다. 기기 인증에는 디지털 인증서, TPM(신뢰 플랫폼 모듈), MDM(모바일 장치 관리) 솔루션 등을 사용할 수 있습니다.

**2.** **동작 기반 인증 및 위험 평가**

  **-** **사용자 행동 분석****(User Behavior Analytics, UBA)**:

   AI와 머신러닝을 활용하여 사용자의 행동 패턴을 분석합니다. 평소와 다른 비정상적인 활동이 감지되면 추가 인증이나 접근 제한이 필요할 수 있습니다.

​    예: 사용자가 평소와 다른 위치에서 접근을 시도하거나, 예상치 못한 시간대에 접속하려 할 때 경고가 발생합니다.

  **-** **위험 기반 인증****(Risk-Based Authentication, RBA)**:

   접속 시도의 위험 수준을 평가하여 인증 강도를 동적으로 조절합니다. 예를 들어, 고위험 상황에서는 추가적인 인증을 요구하고, 저위험 상황에서는 간소화된 인증 절차를 허용합니다.

**3.** **최소 권한 원칙****(Least Privilege Access)**

  **-** **역할 기반 접근 제어****(Role-Based Access Control, RBAC)**:

   사용자는 자신의 역할에 맞는 최소한의 권한만 부여받습니다. 특정 데이터나 애플리케이션에 접근하기 위해 반드시 필요한 경우에만 권한을 요청하고, 이를 승인받아야 합니다.

  **-** **정책 기반 접근 제어****(Policy-Based Access Control, PBAC)**:

   특정 규칙이나 조건에 따라 접근을 제어하는 방식입니다. 예를 들어, 특정 IP 주소에서만 접근이 허용되거나, 특정 시간대에만 시스템에 접속할 수 있습니다.

**4.** **실시간 모니터링 및 지속적인 검증**

  **-** **실시간 모니터링 및** **로깅**:

   모든 접속 시도와 활동을 실시간으로 모니터링하고 기록합니다. 보안 이상 징후가 포착되면 즉시 대응할 수 있도록 설정합니다.

  **-** **연속적 인증****(Continuous Authentication)**:

   사용자가 세션 동안 지속적으로 인증 상태를 유지할 수 있도록 합니다. 이는 특정 시간 간격으로 사용자의 신원을 재검증하거나, 행동 패턴을 분석하여 신뢰할 수 있는 사용자임을 지속적으로 확인

**5.** **데이터 암호화 및 보호**

  **-** **데이터 암호화****(Encryption)**:

   전송 중이거나 저장된 모든 데이터는 암호화됩니다. SSL/TLS를 사용하여 네트워크 통신을 보호하고, 데이터베이스와 파일 시스템의 데이터를 암호화합니다.

  **-** **데이터 분류 및** **레이블링**:

   민감한 데이터는 분류되고, 중요도에 따라 레이블이 지정됩니다. 각 레벨에 따른 접근 정책이 적용되며, 높은 보안 등급이 요구되는 데이터는 더욱 강화된 보호 조치를 취합니다.

**6.** **적응형** **접근 제어**

  **-** **동적 접근 정책****(Dynamic Access Policy)**:

   시스템이 실시간으로 사용자의 상태와 환경을 평가하고, 그에 따라 접근 정책을 자동으로 조정합니다. 예를 들어, 보안 위협이 증가하면 자동으로 접근 권한을 축소하거나, 더 강력한 인증 절차를 요구

  **-** **상황 인식****(Context-Aware Security)**:

   사용자, 기기, 위치, 시간, 네트워크 상태 등 다양한 상황적 요소를 고려하여 접근을 제어합니다. 이러한 접근 방식은 제로 트러스트 원칙을 강화하는 데 필수적입니다.

**7.** **위협 탐지 및 대응**

  **-** **침입 탐지 시스템****(IDS)** **및 침입 방지 시스템****(IPS)**: 네트워크 및 애플리케이션 레벨에서 실시간으로 위협을 감지하고, 이에 대한 자동 대응 조치를 수행합니다.

  **-** **위협** **인텔리전스****(Threat Intelligence)**: 외부 위협 정보를 수집하고 분석하여, 시스템이 최신 위협에 대응할 수 있도록 합니다. 이를 통해, 새로운 공격 벡터나 취약점이 발견되었을 때 빠르게 대응

**8.** **정기적인 보안 검토 및 감사**

  **-** **보안 감사****(Security Audits)**: 정기적으로 시스템 보안 상태를 검토하고, 정책의 준수 여부를 평가합니다. 보안 감사는 잠재적인 취약점을 파악하고, 개선 사항을 도출하는 데 중요합니다.

  **-** **침투 테스트****(Penetration Testing)**: 실제 공격 시나리오를 기반으로 시스템의 보안을 테스트하여, 제로 트러스트 아키텍처의 실효성을 검증합니다.



이러한 제로 트러스트 인증 프로세스는 B2B 고객이 접근하는 모든 자산에 대해 지속적인 신뢰 검증과 보안 보호를 제공하며, 잠재적인 보안 위협을 최소화합니다.

============================================================================================================================

**역할 기반** **엑세스** **제어****(Role Based Access Control, RBAC)****란****?**



**역할 기반 \*****엑세스** **제어****(RBAC)****는 정보 시스템 및 네트워크 보안에서 사용되는 중요한 접근 제어 모델 중 하나입니다****.** 

이 모델은 사용자 역할, 작업 및 권한을 중심으로 구성되며, 시스템에 대한 접근을 조직화하고 제어하기 위해 사용

RBAC는 각 사용자에게 하나 이상의 *”역할”을 할당하고 각 역할에 서로 다른 권한을 부여하여 이를 수행합니다. 

RBAC는 단일 소프트웨어 애플리케이션 또는 여러 애플리케이션에 적용할 수 있습니다.



*엑세스 제어 : 사이버 보안에서 액세스 제어는 사용자가 수행할 수 있는 작업과 볼 수 있는 데이터를

 제한하고 제어하는 도구를 지칭합니다. 스마트폰 잠금을 해제하기 위해 비밀번호를 입력하는 것도 액세스 제어의

 기본적인 예입니다. 비밀번호를 아는 사람만 전화기의 파일과 애플리케이션에 액세스할 수 있습니다.



*역할 : RBAC에서는 역할에 대한 보다 기술적인 정의가 있습니다. 회사 시스템 내에서 사용하기 위해 명확하게 정의

 된 기능 또는 권한의 집합입니다. 각 내부 사용자에게는 적어도 하나의 역할이 할당되며 일부는 여러 역할을

 가질 수 있습니다.

![image-20240811231312499](C:\Users\redmars\AppData\Roaming\Typora\typora-user-images\image-20240811231312499.png)

**RBAC****의 필요성 및 장점**

 **·** **필요성** **:** 보안을 강화하고 정보 시스템의 접근을 효과적으로 관리하여 데이터 보호와 규정 준수를 달성합니다.

 **·** **보안 강화** **:** 역할 기반 접근 제어는 무단 액세스를 제한하고 중요 데이터를 보호하는데 도움을 줍니다.

 **·** **규정 준수** **:** 규제 및 법률을 준수하며 감사 추적을 용이하게 하여 조직의 규정 준수를 지원합니다.

 **·** **관리 효율성** **:** 사용자 및 권한을 중앙에서 관리하여 운영 및 비용을 최적화합니다.

 **·** **업무 효율성** **:** 역할 기반 접근 제어는 사용자가 필요한 권한을 간단하게 얻도록 도와 업무 효율성을 높입니다.



**RBAC****모델의 권한 방식** **3****가지**

 **1****.** **핵심** **RBAC**

   핵심 모델은 RBAC의 모든 단일 구성 요소를 정교하게 만드는 것입니다. 각 역할부터 각 권한까지 모든 것이 이 모델을 통해 지정됩니다. 따라서 이는 다른 2가지 유형의  

   RBAC의 기반이 될 뿐만 아니라 사용자 액세스 권한을 관리하기 위한 독립형 방법으로도 작동할 수 있습니다.



  **·** **핵심** **RBAC****의 기본규칙**

   \- **역할 할당** **:** 사용자는 주체에게 역할이 할당된 경우에만 권한을 행사할 수 있습니다.

   \- **역할 기반 권한 부여** **:** 사용자의 역할에 권한이 부여되어 사용자가 권한이 부여된 역할만 수행할 수 있도록 합니다.

   \- **권한 승인** **:** 사용자는 역할 할당 및 권한 부여에 따라 권한이 부여된 경우 특정 권한을 행사할 수 있습니다.



**2****.** **계층적** **RBAC**

  RBAC 모델의 변형으로, 높은 수준의 역할에 속한 사용자에게는 더 많은 권한과 보안이 제공되고, 낮은 수준의 역할에 속한 사용자에게는 제한된 권한이 부여됩니다. 

  이로써  보안을 강화하고 비용을 절감하는 데 도움이 됩니다.

**3****.** **제한된** **RBAC**

  RBAC 배포의 책임 또는 임무는 이 표준을 통해 지정됩니다. 구현 또는 직무 분리(SD)는 요구 사항에 따라 정적이거나 동적일 수 있습니다.



  **·** **정적 모델****(Static Model — SSD) :** 상호 배타적인 역할이 동일한 개인에게 부여되지 않도록 방지합니 다. 예를 들어, 전자 상거래 플랫폼에서 구매자와 판매자 역할은 

   상호 배타적이며 사용자는 하나의 역할 만 가질 수 있습니다. 이로써 역할 간 권한 충돌을 방지하고 사용자에게 엄격한 역할을 할당합니다.

  **·** **동적 모델****(Dynamic Model — DSD) :** 사용자가 제한없이 여러 권한을 가질 수 있지만, 동일한 세션에서는 동시에 사용하는 것은 불가능합니다. 사용자는 특정 권한을

​    실제로 사용하려면 추가 승인이 필요합니다. 이는 더 유연한 권한 관리를 가능하게 합니다.

   RBAC 모델의 선택은 조직의 보안 및 역할 관리 요구에 따라 다를 수 있으며, 이러한 다양한 방식을 활용하여 사용자 액세스를 효과적으로 관리할 수 있습니다.



**RBAC****의 예시**

  조직은 역할 또는 그룹별로 사용자를 지정할 수 있고, 역할 그룹에 사용자를 추가한다는 것은 새 사용자가 해당 특정 그룹의 모든 권한에 액세스할 수 있음을 의미합니다.

  조직은 관리자, 업무별 최종 사용자 또는 게스트를 포함하도록 역할을 분할할 수 있습니다.

  예를 들면 다음과 같은 역할이 있습니다 :

   **·** 조직의 소프트웨어 엔지니어링 도구(GitHub, Docker 및 Jenkins)에 대한 역할과 액세스 권한이 부여된 **소프트웨어 엔지니어**

   **·** 조직의 마케팅 도구(이메일 마케팅 목록, Google Analytics 또는 소셜 미디어 프로필)에 대한 역할과 액세스 권한이 부여된 **마케팅 담당자**

   **·** 조직의 HR 관련 도구(ADP, Oracle Cloud Human Capital Management 또는 Paycor)에 대한 역할과 액세스 권한이 부여된 **인사 담당자**

  소프트웨어 엔지니어는 같은 회사의 HR 또는 마케팅 담당자가 보유하고 있는 도구나 파일에 액세스할 수 없지만 작업을 완료하는 데 필요한 도구에는 액세스할 수 있습니다.   

  마찬가지로 마케팅 담당자는 자신의 역할에 따라 필요한 도구에 액세스할 수 있지만 HR 또는 소프트웨어 엔지니어링 도구에는 액세스할 수 없습니다.



**RBAC vs. ABAC(Attribute-Based Access Control)**

 RBAC(역할 기반 액세스 제어)와 ABAC(속성 기반 액세스 제어)는 모두 액세스 제어 방법이지만 

 접근 방식이 다릅니다. **RBAC**는 사용자의 역할에 따라 액세스 권한을 부여하는 반면,



 **ABAC**는 다음 범주의 조합을 기반으로 액세스를 제어합니다.

  **·** **사용자 속성** **:** 사용자 이름, 국적, 조직, ID, 역할 및 보안 허가가 포함될 수 있습니다 .

  **·** **자원 속성** **:** 액세스 되는 개체의 소유자, 이름 및 데이터 생성 날짜를 설명할 수 있습니다.

  **·** **작업 속성** **:** 액세스 중인 시스템 또는 애플리케이션과 관련된 작업을 설명합니다.

  **·** **환경적 속성** **:** 액세스 위치, 액세스 시간 및 위협 수준이 포함될 수 있습니다.



 ABAC는 특정 속성을 추가하여 권한 부여 옵션을 기하급수적으로 증가시켜 RBAC에 비해 다른 수준의

 제어를 구현합니다. RBAC보다 훨씬 더 유연하지만 이러한 유연성을 적절하게 구현 및 관리하지 않을

 경우 위험을 증가시킬 수 있습니다.

![image-20240811231327523](C:\Users\redmars\AppData\Roaming\Typora\typora-user-images\image-20240811231327523.png)

============================================================================================================================

**통신사** **K****의 사내 관리 시스템에** **RBAC****를 적용하기 위한 데이터베이스****(****역할****,** **사용자****,** **권한****)** **테이블을 설계하고** **ERD****를 작성하세요****.\******힌트\******:** **사용자 테이블****(Users),** **역할 테이블****(Roles),** **권한 테이블****(Permissions)****과 사용자****-****역할****(****UserRoles****),** **역할****-****권한****(****RolePermissions****)** **관계 테이블을 설계하세요****. ERD****를 통해 각 테이블 간 관계를 시각화하세요****.**



RBAC(Role-Based Access Control)은 역할 기반 접근 제어를 통해 사용자가 특정 역할에 따라 시스템 내에서 수행할 수 있는 작업을 제어하는 방법입니다. 

이를 적용하기 위해 필요한 기본적인 데이터베이스 테이블은 다음과 같습니다:



**1. Users** **테이블**: 시스템의 사용자 정보를 저장.

**2. Roles** **테이블****:** 시스템 내의 역할 정보를 저장.

**3. Permissions** **테이블**: 시스템에서 수행할 수 있는 권한(작업) 정보를 저장.

**4.** **UserRoles** **테이블****:** 사용자와 역할 간의 매핑 정보를 저장 (Many-to-Many 관계).

**5.** **RolePermissions** **테이블****:** 역할과 권한 간의 매핑 정보를 저장 (Many-to-Many 관계).



**1.** **테이블 설계**

**a) Users** **테이블**

CREATE TABLE Users (

  user_id INT PRIMARY KEY AUTO_INCREMENT,

  username VARCHAR(50) NOT NULL UNIQUE,

  password VARCHAR(255) NOT NULL,

  email VARCHAR(100) UNIQUE,

  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP

);

user_id: 사용자 ID, 기본 키.

username: 사용자 이름, 시스템에서 고유해야 함.

password: 사용자 비밀번호 (해싱된 형태로 저장).

email: 사용자 이메일 주소, 고유해야 함.

created_at, updated_at: 사용자 생성 및 업데이트 타임스탬프.



**b****) Roles** **테이블**

CREATE TABLE Roles (

  role_id INT PRIMARY KEY AUTO_INCREMENT,

  role_name VARCHAR(50) NOT NULL UNIQUE,

  description VARCHAR(255)

);

role_id: 역할 ID, 기본 키.

role_name: 역할 이름 (예: Admin, Manager, User), 고유해야 함.

description: 역할에 대한 설명.



**c****) Permissions** **테이블**

CREATE TABLE Permissions (

  permission_id INT PRIMARY KEY AUTO_INCREMENT,

  permission_name VARCHAR(50) NOT NULL UNIQUE,

  description VARCHAR(255)

);



permission_id: 권한 ID, 기본 키.

permission_name: 권한 이름 (예: ViewDashboard, EditUser), 고유해야 함.

description: 권한에 대한 설명.



**d****)** **UserRoles** **테이블**

CREATE TABLE UserRoles (

  user_id INT,

  role_id INT,

  PRIMARY KEY (user_id, role_id),

  FOREIGN KEY (user_id) REFERENCES Users(user_id),

  FOREIGN KEY (role_id) REFERENCES Roles(role_id)

);

user_id: Users 테이블의 사용자 ID, 외래 키.

role_id: Roles 테이블의 역할 ID, 외래 키.

PRIMARY KEY (user_id, role_id): 복합 기본 키로 사용자의 역할을 고유하게 관리.



**e****)** **RolePermissions** **테이블**

CREATE TABLE RolePermissions (

  role_id INT,

  permission_id INT,

  PRIMARY KEY (role_id, permission_id),

  FOREIGN KEY (role_id) REFERENCES Roles(role_id),

  FOREIGN KEY (permission_id) REFERENCES Permissions(permission_id)

);

role_id: Roles 테이블의 역할 ID, 외래 키.

permission_id: Permissions 테이블의 권한 ID, 외래 키.

PRIMARY KEY (role_id, permission_id): 복합 기본 키로 역할의 권한을 고유하게 관리.



**2****. ERD (Entity-Relationship Diagram)** **작성**

  ERD를 통해 각 테이블 간의 관계를 시각적으로 표현합니다:

![image-20240811231530955](C:\Users\redmars\AppData\Roaming\Typora\typora-user-images\image-20240811231530955.png)

![image-20240811231535249](C:\Users\redmars\AppData\Roaming\Typora\typora-user-images\image-20240811231535249.png)

**3****. ERD** **설명**

  Users와 Roles는 Many-to-Many 관계로, 하나의 사용자는 여러 역할을 가질 수 있고, 하나의 역할은 여러 사용자에게 할당될 수 있습니다. 이를 UserRoles 중간 테이블이 연결합니다.

  Roles와 Permissions도 Many-to-Many 관계로, 하나의 역할은 여러 권한을 가질 수 있으며, 하나의 권한은 여러 역할에 할당될 수 있습니다. 이를 RolePermissions 중간 테이블이 연결합니다.

  ERD에서는 각 테이블과 관계를 시각화하여, 각 엔터티 간의 관계를 쉽게 이해할 수 있도록 구성하였습니다.



결론

이 데이터베이스 설계를 통해 통신사 K의 사내 관리 시스템에 RBAC(Role-Based Access Control)를 효율적으로 적용할 수 있습니다. 사용자, 역할, 권한 간의 관계를 명확히 정의하여, 관리자는 역할에 따라 권한을 쉽게 부여하고 관리할 수 있으며, 사용자 접근 제어를 체계적으로 관리할 수 있습니다.



**ERD (Entity-Relationship Diagram)**



![image-20240811231553984](C:\Users\redmars\AppData\Roaming\Typora\typora-user-images\image-20240811231553984.png)

![image-20240811231557896](C:\Users\redmars\AppData\Roaming\Typora\typora-user-images\image-20240811231557896.png)

![image-20240811231602115](C:\Users\redmars\AppData\Roaming\Typora\typora-user-images\image-20240811231602115.png)

![image-20240811231605230](C:\Users\redmars\AppData\Roaming\Typora\typora-user-images\image-20240811231605230.png)

![image-20240811231608961](C:\Users\redmars\AppData\Roaming\Typora\typora-user-images\image-20240811231608961.png)

![image-20240811231613301](C:\Users\redmars\AppData\Roaming\Typora\typora-user-images\image-20240811231613301.png)

============================================================================================================================

**중복 로그인 방지**



**■** **Spring Security** **구조****,** **흐름 그리고 역할 알아보기**



  **1. Spring** **Security****란****?**

   스프링 시큐리티는 인증(Authentication) ,권한(Authorize) 부여 및 보호 기능을 제공하는 프레임워크다.

​    Java / Java EE 프레임워크

​      개발을 하면서 보안 분야는 시간이 많이 소요되는 활동들 중 하나다. Spring Security를 사용함으로써 짜여진 내부 로직을 통해 인증, 권한 확인에 필요한 기능과

​      옵션들을 제공한다.



  **2.** **인증****(Authentication) ,** **인가****(Authorization)**

   *인증과* *인가란 무엇일까**?* *보통 인증 절차를 거친 후 인가 절차를 진행한다**.*

​    \- 인증: 해당 사용자가 본인이 맞는지를 확인하는 절차.

​    \- 인가: 인증된 사용자가 요청된 자원에 접근 가능한가를 결정하는 절차



  **3.** **인증** **방식**

​    1. credential 방식: username, password를 이용하는 방식

​    2. 이중 인증(two factor 인증): 사용자가 입력한 개인 정보를 인증 후, 다른 인증 체계(예: 물리적인 카드)를 이용하여 두가지의 조합으로 인증하는 방식이다.

​    3. 하드웨어 인증: 자동차 키와 같은 방식

​    이중 Spring Security는 credential 기반의 인증을 취합니다.

​     . principal: 아이디 (username), credential: 비밀번호 (password)

​    특정 자원에 대한 접근을 제어하기 위해서는 **권한**을 가지게 된다.

​    특정 권한을 얻기 위해서는 유저는 인증정보(Authentication)가 필요하고 관리자는 해당 정보를 참고해 권한을 인가(Authorization)한다.

​    보편적으로 username - password 패턴의 인증방식을 거치기 때문에 **스프링** **시큐리티는** **principal - credential** **패턴**을 가지게 된다.



   **4. Spring** **Security****의 특징**

​     \- Filter를 기반으로 동작한다. : Spring MVC와 분리되어 관리하고 동작할 수 있다.

​     \- Bean으로 설정할 수 있다. : Spring Security 3.2부터는 XML설정을 하지 않아도 된다.



  **5.** **Spring Security Architecture(****구조****)**

![image-20240811231705077](C:\Users\redmars\AppData\Roaming\Typora\typora-user-images\image-20240811231705077.png)

   **1****. Http Request** **수신** : 사용자가 로그인 정보와 함께 인증 요청을 한다.



   **2****.** **유저 자격을 기반으로 인증토큰 생성** : AuthenticationFilter가 요청을 가로채고, 가로챈 정보를 통해

​                          UsernamePasswordAuthenticationToken의 인증용 객체를 생성한다.



   **3****.** **FIlter****를 통해** **AuthenticationToken****을** **AuthenticationManager****로** **위임**

​      AuthenticationManager의 구현체인 ProviderManager에게 생성한 UsernamePasswordToken 객체를

​      전달한다.



   **4****.** **AuthenticationProvider****의 목록으로 인증을 시도**

​     AutenticationManger는 등록된 AuthenticationProvider들을 조회하며 인증을 요구한다.



   **5****.** **UserDetailsService****의 요구**

​     실제 데이터베이스에서 사용자 인증정보를 가져오는 UserDetailsService에 사용자 정보를 넘겨준다.



   **6****.** **UserDetails****를 이용해** **User****객체에 대한 정보 탐색**

​     넘겨받은 사용자 정보를 통해 데이터베이스에서 찾아낸 사용자 정보인 UserDetails 객체를 만든다.



   **7****. User** **객체의 정보들을** **UserDetails****가** **UserDetailsService****(****LoginService****)****로 전달**

​     AuthenticaitonProvider들은 UserDetails를 넘겨받고 사용자 정보를 비교한다.



   **8****.** **인증 객체** **or** **AuthenticationException**

​     인증이 완료가되면 권한 등의 사용자 정보를 담은 Authentication 객체를 반환한다.



   **9****.** **인증 끝**

​     다시 최초의 AuthenticationFilter에 Authentication 객체가 반환된다.



   **10****.** **SecurityContext****에 인증 객체를 설정**

​     Authentication 객체를 Security Context에 저장한다.



최종적으로는 SecurityContextHolder는 세션 영역에 있는 SecurityContext에 Authentication 객체를 저장한다. 사용자 정보를 저장한다는 것은 스프링 시큐리티가 전통적인 세선-쿠키 기반의 인증 방식을 사용한다는 것을 의미한다.

============================================================================================================================

**■** **사용자의 중복 요청 방지하기****(feat.** **멱등키****,** **Redis****)**

**1.** **중복 요청을 어떻게 식별할까****? (****멱등키****)**

  먼저 중복 요청을 방지하기 위해서는 중복 요청에 대해서 '멱등성'을 보장해야 했습니다.

  멱등성이란, 첫 번째 수행을 한 뒤 여러 차례 적용해도 결과를 변경시키지 않는 작업 또는 기능의 속성을 뜻합니다.

  즉, 멱등한 작업의 결과는 한 번 수행하든 여러 번 수행하든 같습니다.

  멱등성을 보장해서 여러 번의 중복 요청이 와도 처음 요청 시에만 동선을 생성하고, 그 후에는 생성한 결과가 변하지 않게 해야합니다. 

  여기서 멱등성을 보장하는 시간은 서버의 최대 응답 지연 시간을 고려해서 설정했습니다.

  최대 응답 지연 시간 동안의 들어오는 요청은 모두 중복 요청이라고 판단했습니다.

  그래서 저는 최대 10초 동안 응답 지연이 있을 수 있다고 고려해서 멱등성 보장 시간을 10초로 결정했습니다.

  그리고 요청이 중복되었음을 판단할 요청의 식별자, 즉 멱등키가 필요했습니다.

  해당 식별자는 현재 비스니스에서 '1명의 사용자의 같은 날짜 동선 생성 요청'을 식별해야 했습니다.

  그래서 멱등키는 다음과 같은 요소가 들어가도록 결정하게 되었습니다.



   addRoute(동선 생성 메소드 이름)

   memberId(사용자 식별자)

   date(동선 날짜)

   이후 구현이 어떻게 되든 우선 중복 요청을 식별하는 멱등키는 위의 요소를 포함하여 설계를 진행했습니다.

   이렇게 처음 요청에서 멱등키를 생성하고, 요청마다 들어오는 멱등키를 체크하여 중복 요청을 방지할 수 있습니다.



 **2** **Redis** **Set****을 사용한 중복 방지 구현**

  멱등키를 저장하는 Redis의 자료 구조로는 Set을 선택했습니다.

   Redis의 명령 중 SET을 사용하고 NX를 옵션으로 전달하여 명령을 수행할 것입니다.

   (Redis 2.6.12 이전에는 SETNX 명령이 별도로 있었지만, Deprecated 되어 SET 명령어에 NX를 옵션으로 전달해야 합니다.)

   SET : key-value 형태인 Set 자료 구조의 key에 해당하는 value를 지정하는 명령어

   NX 옵션 : Not Exist의 약자로, Key가 존재하지 않을 때만 value를 지정하는 명령어

   해당 명령어를 사용한 Flow는 다음과 같습니다.

1. 사용자의 요청이 들어오면 멱등성이 보장되는 멱등키를 생성한다.
2. 해당 멱등키를 Redis에 Set 자료 구조로 SET NX를 통해 저장한다. (Spring Data Redis의 RedisTemplate 사용)
3. 멱등키에 해당하는 키가 존재하지 않으면 만료 시간이 10초로 멱등키를 저장하고 Application에 true를 반환한다.
4. 멱등키에 해당하는 키가 이미 존재한다면 저장하지 않고 Application에 false를 반환한다.
5. SET NX 명령어 성공 여부에 따라 분기 처리로 로직을 수행한다.

​     True : 첫 요청으로 판단하여 동선을 생성한다.

​     False : 중복된 요청으로 판단하여 예외를 발생시킨다.

 ![image-20240811231757874](C:\Users\redmars\AppData\Roaming\Typora\typora-user-images\image-20240811231757874.png)

============================================================================================================================

**인증방식의 전환에 따른 방안을 제시하고 프로세스를 설계하시오**

 인증방식을 기존의 방식에서 새로운 방식으로 전환하는 것은 보안성 강화와 사용자 경험 개선을 위한 중요한 결정입니다. 이러한 전환은 단계적이고 신중하게 수행되어야 하며, 

 사용자와 시스템에 미치는 영향을 최소화해야 합니다. 

**1.** **인증방식 전환의 필요성 분석 및 선택**

  **a)** **기존 인증방식 평가**

   **-** **보안성** **분석**: 현재 사용 중인 인증방식의 보안 수준을 평가합니다. 예를 들어, 단순 비밀번호 기반 인증이더라도 취약한 비밀번호, 피싱 공격, 브루트포스 공격 등에 대한 취약성을 분석합니다.

   **-** **사용자 경험****(UX)** **평가**: 기존 인증방식이 사용자에게 제공하는 경험을 평가합니다. 예를 들어, 인증 절차가 복잡하거나 시간이 많이 걸리는지, 또는 사용자가 자주 비밀번호를 잊는 문제가 있는지 확인

  **b)** **새로운 인증방식 선택**

   **-** **강화된** **보안성**: 다중 인증(MFA), 생체 인식(Fingerprint, Face ID), OAuth2, OpenID Connect, 또는 패스워드리스 인증(Passwordless Authentication)과 같은 강력한 보안 방식을 선택합니다.

   **-** **사용자 편의성**: 사용자가 쉽게 접근하고 사용할 수 있는 인증방식을 선택합니다. 예를 들어, OTP(One-Time Password) 또는 FIDO(패스워드리스 인증)를 활용할 수 있습니다.

**2.** **전환 전략 수립**

  **a)** **단계적 전환**

   **-** **병행 운영 단계****(Parallel Operation)**: 기존 인증방식과 새로운 인증방식을 일정 기간 동안 병행 운영합니다. 이는 사용자가 새로운 인증방식에 적응할 시간을 제공하며, 시스템 안정성을 검증

예: 사용자가 기존 비밀번호 인증을 통해 로그인한 후, 새로운 인증방식(예: OTP, 생체 인식)으로 전환하도록 안내.

   **-** **사용자 그룹별 전환**: 모든 사용자에게 한꺼번에 전환을 요구하지 않고, 특정 사용자 그룹부터 전환을 시작합니다. 이는 전환 과정에서 발생할 수 있는 문제를 최소화할 수 있습니다.

예: 내부 직원부터 새로운 인증방식으로 전환하고, 이후 외부 사용자를 점진적으로 전환.

  **b)** **사용자 교육 및 지원**

   **-** **가이드 제공**: 새로운 인증방식 사용법에 대한 가이드라인, FAQ, 튜토리얼 비디오 등을 제공하여 사용자가 전환 과정에서 어려움을 겪지 않도록 합니다.

예: 새로운 인증 방식이 생체 인식일 경우, 기기에서 생체 인식을 설정하는 방법에 대한 가이드 제공.

   **-** **헬프데스크** **지원 강화**: 전환 과정에서 발생할 수 있는 문제를 신속히 해결하기 위해 헬프데스크를 강화합니다. 사용자 문의에 대한 실시간 지원을 제공하여 문제 발생 시 빠르게 대응할 수 있도록 합니다.

**3.** **시스템 및 데이터 준비**

  **a)** **시스템 통합 및 테스트**

   **-** **시스템 통합**: 새로운 인증방식이 기존 시스템과 완벽하게 통합되도록 합니다. 이는 인증 서버, 사용자 데이터베이스, 애플리케이션 서버 간의 원활한 연동을 의미합니다.

   **-** **전환 전 테스트**: 새롭게 도입되는 인증방식을 다양한 환경(브라우저, 운영체제, 기기)에서 충분히 테스트하여 모든 사용자가 원활하게 이용할 수 있도록 합니다.

예: 다양한 모바일 기기와 웹 브라우저에서 OTP 또는 생체 인식 인증이 제대로 동작하는지 검증.

  **b)** **데이터** **마이그레이션**

   **-** **사용자 데이터 준비**: 새로운 인증방식에 필요한 사용자 데이터를 준비합니다. 예를 들어, 생체 인식 정보를 저장하거나 OTP 발송을 위한 연락처 정보를 수집합니다.

   **-** **데이터 암호화 및 보호**: 전환 과정에서 사용자의 민감한 데이터를 보호하기 위해 강력한 암호화 방식을 사용하고, 데이터 전송 시 SSL/TLS를 통해 보안을 강화합니다.

**4.** **모니터링 및 피드백 수집**

  **a)** **실시간 모니터링**

   **-** **전환 상태 모니터링**: 인증 전환 과정에서 발생하는 모든 로그인 시도와 오류를 실시간으로 모니터링하여 문제 발생 시 즉각 대응할 수 있도록 합니다.

예: 실패한 로그인 시도의 로그를 분석하여 새로운 인증방식에서 발생할 수 있는 문제를 식별.

  **b)** **사용자 피드백 수집**

   **-** **피드백 루프 설정**: 전환 과정 중 사용자로부터 피드백을 수집하여 불편 사항을 파악하고, 이를 바탕으로 인증방식을 개선합니다.

예: 로그인 후 설문조사를 통해 사용자가 새로운 인증방식에 대해 어떻게 느끼는지 조사.

**5.** **전환 완료 및 유지 관리**

  **a)** **전환 완료 단계**

  **-** **기존 인증방식 중단**: 병행 운영 단계가 종료되면 기존 인증방식을 완전히 중단하고, 모든 사용자가 새로운 인증방식을 사용하도록 합니다.

  **-** **최종 데이터 검토**: 새로운 인증방식에 대한 최종 데이터를 검토하여, 모든 사용자가 문제없이 전환되었는지 확인합니다.

  **b)** **지속적인 유지보수 및 업데이트**

  **-** **보안 업데이트**: 새로운 인증방식에 대한 최신 보안 패치와 업데이트를 주기적으로 적용하여 보안성을 유지합니다.

  **-** **지속적인 모니터링**: 사용자가 새로운 인증방식을 지속적으로 원활히 사용할 수 있도록 모니터링을 계속하며, 필요 시 추가적인 개선 작업을 수행합니다.

**결론**

인증방식 전환은 사용자 보안과 경험을 모두 향상시키기 위한 중요한 과정입니다. 위의 방안과 프로세스를 통해 사용자와 시스템에 미치는 영향을 최소화하며, 안전하고 원활한 전환을 달성할 수 있습니다. 또한, 전환 후에도 지속적인 모니터링과 피드백 수집을 통해 인증방식의 안정성을 유지하고, 필요시 개선할 수 있도록 준비해야 합니다.



============================================================================================================================

**인증방식의 전환에 따른 방안을 제시하고 프로세스를 설계하시오**

A고객사의 인증 방식 개선을 위해 다음과 같은 방안을 제안하고 프로세스를 설계해 드리겠습니다:

 **1.** **토큰** **기반 인증 방식으로 전환**

  기존의 세션 기반 인증에서 JWT(JSON Web Token) 기반 인증으로 전환합니다. 이는 다음과 같은 이점을 제공합니다:

   \- 서버의 부하 감소: 세션 저장소가 필요 없어 서버 확장성이 향상됩니다.

   \- 다중 서버 환경에서의 용이성: 토큰이 클라이언트 측에서 관리되어 서버 간 세션 공유 문제가 해결됩니다.

   \- 모바일 앱 및 다양한 클라이언트 지원 용이성

 **2.** **리프레시** **토큰 도입**

   \- 액세스 토큰의 유효 기간을 짧게 설정하고, 리프레시 토큰을 통해 새로운 액세스 토큰을 발급받는 방식을 도입합니다:

   \- 액세스 토큰 유효 기간: 15분

   \- 리프레시 토큰 유효 기간: 30일 (재발급 시 갱신)

 **3.** **중복** **로그인 방지 메커니즘**

   사용자별로 고유한 리프레시 토큰을 관리하여 중복 로그인을 방지합니다:

   \- 새로운 로그인 시 기존 리프레시 토큰 무효화

   \- 리프레시 토큰 데이터베이스에서 사용자당 하나의 유효한 토큰만 유지

 **4.** **개선된** **인증 프로세스 설계**

   a) 로그인 프로세스: 

​     1. 사용자가 아이디와 비밀번호로 로그인 요청

​     2. 서버에서 자격 증명 확인

​     3. 유효한 경우, 액세스 토큰과 리프레시 토큰 생성

​     4. 기존 리프레시 토큰이 있다면 무효화하고 새로운 토큰 저장

​     5. 클라이언트에 토큰 전송

   b) 인증된 요청 처리:

​     1. 클라이언트가 액세스 토큰과 함께 요청

​     2. 서버에서 토큰 유효성 검증

​     3. 유효한 경우 요청 처리, 그렇지 않으면 401 Unauthorized 응답

   c) 토큰 갱신 프로세스:

​     1. 액세스 토큰 만료 시 클라이언트가 리프레시 토큰으로 갱신 요청

​     2. 서버에서 리프레시 토큰 유효성 검증

​     3. 유효한 경우 새로운 액세스 토큰 발급, 그렇지 않으면 재로그인 요구

   d) 로그아웃 프로세스:

​     1. 클라이언트에서 로그아웃 요청

​     2. 서버에서 해당 사용자의 리프레시 토큰 무효화

​     3. 클라이언트에 로그아웃 성공 응답

​     4. 보안 강화 방안

​       . HTTPS 사용 필수

​       . 토큰 암호화 및 서명 검증

​       . 액세스 토큰에 최소한의 정보만 포함 (사용자 ID, 권한 등)

​       . 주기적인 리프레시 토큰 순환 (예: 7일마다)



이러한 개선된 인증 방식은 A고객사의 채널 확대 및 사용자 증가에 따른 인증 및 세션 관리 문제를 효과적으로 해결할 수 있을 것입니다. 시스템의 확장성이 향상되고, 보안성도 강화되며, 다양한 클라이언트 환경에서도 일관된 사용자 경험을 제공할 수 있습니다.

============================================================================================================================

**인증 불일치 또는** **Session** **만료에 따른 처리에 대한** **UI** **처리 방안을 설계하시오**

 인증 불일치 또는 세션 만료는 사용자 경험에 큰 영향을 미칠 수 있습니다. 따라서 이러한 상황이 발생했을 때 사용자에게 명확한 안내와 사용성을 보장하는 UI 처리 방안을 마련하는 것이 중요합니다.

**1.** **세션 만료 처리**

  **a)** **세션 만료 전 사용자 알림**

​    **-** **세션 만료 경고 메시지**: 세션이 만료되기 몇 분 전(예: 5분 전)에 사용자에게 세션이 곧 만료될 것임을 알려주는 경고 메시지를 표시합니다.

​      **. UI** **요소**: 모달 창 또는 화면 상단에 바 형태의 알림 배너를 사용합니다.

​      **.** **내용**: "세션이 5분 후 만료됩니다. 계속 사용하시려면 '연장' 버튼을 클릭하세요.“

​      **.** **액션**: 연장 버튼을 클릭하면 세션이 연장되고, 알림이 사라집니다.

  **b)** **세션 만료 후 처리**

​    **-** **세션 만료 알림** **모달**: 사용자가 세션 만료 후 페이지 내에서 활동을 시도할 때, 즉시 세션 만료 알림 모달 창을 표시합니다.

​     **. UI** **요소**: 모달 창

​     **.** **내용**: "세션이 만료되었습니다. 계속 사용하시려면 다시 로그인해주세요.“ 

​     **.** **액션**: 로그인 버튼을 클릭하면 로그인 페이지로 리디렉션됩니다. 이전에 작업하던 내용을 복구할 수 있는 옵션을 제공할 수 있습니다.

​    **-** **자동 로그아웃 후** **리디렉션**: 세션이 만료되면 자동으로 로그아웃 처리되고, 로그인 페이지로 리디렉션됩니다.

**. UI** **요소**: 로그인 페이지로의 자동 리디렉션

**.** **내용**: 로그인 페이지에 "세션이 만료되었습니다. 다시 로그인해주세요."라는 메시지를 표시합니다.

**.** **액션**: 로그인 후, 사용자가 이전에 있던 페이지나 작업을 이어서 할 수 있도록 리디렉션합니다.

**2.** **인증 불일치 처리**

  **a)** **인증 불일치 발생 시 알림**

​    **-** **즉각적인 오류 메시지**: 사용자가 잘못된 자격 증명(예: 비밀번호, 2FA 코드)을 입력했을 때, 즉시 오류 메시지를 표시합니다.

**. UI** **요소**: 입력 필드 아래 또는 모달 창으로 오류 메시지 표시

**.** **내용**: "입력하신 비밀번호가 일치하지 않습니다. 다시 시도해주세요."

**.** **액션**: 입력 필드가 강조되며, 사용자가 쉽게 다시 입력할 수 있도록 처리합니다. 일정 횟수 이상 오류 발생 시 CAPTCHA 또는 추가 보안 절차를 요구할 수 있습니다.

  **b)** **인증이 필요할 때**

   **-** **재인증** **요구** **모달**: 사용자가 중요 작업(예: 결제, 민감한 데이터 접근 등)을 수행할 때 인증이 필요할 경우, 재인증을 요구하는 모달 창을 표시합니다.

**. UI** **요소**: 모달 창

**.** **내용**: "이 작업을 수행하기 위해 다시 인증이 필요합니다. 비밀번호를 입력해주세요."

**.** **액션**: 비밀번호 입력 후, 인증이 성공하면 작업을 계속 진행합니다. 인증 실패 시, 오류 메시지와 함께 다시 입력할 수 있도록 합니다.

**3.** **일관된 사용자 경험 제공**

  **a)** **일관된 디자인 및 메시지**

​    **-** **통일된** **UI** **스타일**: 세션 만료나 인증 불일치 상황에서 표시되는 모든 메시지와 알림은 일관된 디자인과 언어를 사용하여 혼란을 최소화합니다.

**-** **명확한 가이드 제공**: 사용자에게 필요한 조치를 명확하게 안내하고, 쉽게 이해할 수 있도록 간결한 언어로 설명합니다.

**b)** **접근성** **및** **반응성** **고려**

​    **-** **모든 기기에서 동일한 사용자 경험 제공**: 데스크톱, 태블릿, 모바일 등 다양한 기기에서 동일한 UI 경험을 제공하도록 반응형 디자인을 적용합니다.

**-** **접근성****(Accessibility)**: UI 요소가 스크린 리더와 호환되며, 키보드 및 보조 장치로 쉽게 접근할 수 있도록 설계합니다.

**4.** **사용자 피드백 및 개선**

  **a)** **사용자 피드백 루프**

​    **-** **피드백 수집 기능 제공**: 세션 만료 또는 인증 불일치가 발생한 후 사용자가 문제를 보고하거나, UI에 대한 피드백을 제공할 수 있는 기능을 제공합니다.

**UI** **요소**: 피드백 버튼 또는 폼

**내용**: "이 문제가 반복되나요? 피드백을 남겨주세요."

  **b)** **지속적인** **UI** **개선**

​    **-** **사용자 피드백 기반 개선**: 수집된 피드백을 분석하여 UI/UX를 지속적으로 개선합니다.

**결론**

이와 같은 UI 처리 방안을 통해 인증 불일치와 세션 만료 상황에서도 사용자가 혼란 없이 시스템을 이용할 수 있도록 지원할 수 있습니다. 명확한 알림과 일관된 사용자 경험을 제공함으로써 사용자의 만족도를 높이고, 보안성과 사용 편의성을 동시에 강화할 수 있습니다.

============================================================================================================================

**다수의 사용자가 다수의** **인벤토리** **예약을 하기 위한 데이터 모델의 문제점을 확인하고****,** **해결을 위한 방안을 제시하시오****.** **예약 처리 프로세스는** **Async** **한 방식으로 구현 되어야 한다**



**1.** **문제 정의**

  다수의 사용자가 동일한 인벤토리(예: 항공편 좌석, 호텔 객실, 상품 재고 등)를 동시에 예약하려고 할 때, 데이터 모델과 예약 처리 프로세스에서 동시성 문제가 발생할 수 있습니다. 

  이로 인해 중복 예약, 데이터 불일치, 예약 실패 등이 발생할 수 있습니다.



**2.** **문제점 분석**

  동시성 이슈는 주로 다음과 같은 문제점에서 발생합니다



  **-** **레이스 컨디션****(Race Condition)**:

   여러 사용자가 동시에 같은 인벤토리 아이템을 예약하려고 할 때, 각 프로세스가 동시에 데이터베이스에 접근하여 데이터 일관성을 깨뜨리는 문제가 발생할 수 있습니다.



  **-** **잠금 문제****(Locking Issues)**:

   데이터베이스에서 동시성 제어를 위해 레코드를 잠그는 방식이 비효율적이거나, 잠금 해제가 제대로 이루어지지 않아 데드락(Deadlock) 또는 다른 사용자 요청이 차단되는 문제가 발생할 수 있습니다.

 

  \- **비효율적인 데이터 모델**

   인벤토리의 상태를 제대로 반영하지 못하는 데이터 모델로 인해 동시성 제어가 어려워질 수 있습니다. 특히 비동기 방식으로 구현된 경우, 동시성 제어가 더욱 어렵습니다.



**3.** **해결 방안 제시**

  동시성 문제를 해결하기 위한 방안을 제시하며, 제약 조건(비동기 처리)을 충족하도록 설계합니다.



**■ 방안** **1: Optimistic Locking (****낙관적 잠금****)**



  **1.** **버전 관리 추가**

​    \- 예약 테이블에 version 필드를 추가하여 각 예약 요청 시점의 상태를 추적합니다.
​    \- 업데이트 시 해당 레코드의 version 값이 현재와 일치하는 경우에만 업데이트를 허용하며, 불일치 시 재시도를 요청하거나 오류를 반환합니다. 



  **2.** **비동기** **처리**

​    \- 예약 요청은 비동기적으로 처리되며, 업데이트 요청 시 Optimistic Locking을 통해 동시성 문제를 해결합니다.

​    \- 클라이언트는 실패한 경우 이를 인지하고, 다시 시도할 수 있도록 설계합니다.



**■ 방안** **2: Pessimistic Locking (****비관적 잠금****)**



  **1.** **레코드 잠금**:

\- 사용자가 특정 인벤토리를 예약하려고 할 때 해당 인벤토리 레코드를 읽기 전에 잠급니다. 

 이는 다른 사용자가 동시에 해당 레코드를 읽거나 수정하지 못하도록 합니다.

-Pessimistic Locking은 일반적으로 더 높은 동시성 제어를 제공하지만, 성능에 부정적인 영향을 미칠 수 있습니다.

\-

  **2.** **비동기** **큐 사용**:

\- 예약 요청을 비동기 큐(예: RabbitMQ, Kafka)에 넣고, 예약 처리를 하나씩 큐에서 꺼내어 처리합니다. 

 이렇게 하면 비관적 잠금으로 인한 성능 저하를 완화할 수 있습니다.

**■ 방안** **3:** **데이터 모델 개선 및 분산 시스템 도입**



  **1.** **재고 감소 시나리오**

   \- 재고를 관리하는 인벤토리 테이블과 예약 테이블을 분리하고, 인벤토리 테이블에서 available_quantity를 관리합니다.

   \- 예약 요청이 들어올 때마다 비동기적으로 재고를 감소시키는 요청을 보내고, 성공 시 예약을 완료합니다.



  **2. CQRS** **패턴**

   \- Command Query Responsibility Segregation(CQRS) 패턴을 도입하여, 쓰기 작업(예약 및 재고 감소)과 읽기 작업(인벤토리 상태 조회)을 분리합니다.

   \- 예약은 비동기적으로 처리되며, 쓰기 작업이 완료되면 이벤트를 통해 읽기 모델을 업데이트합니다.



  **3.** **분산 트랜잭션 관리**

   \- 분산 시스템(예: Redis, Cassandra)에서 트랜잭션을 관리하여, 각 노드에서의 동시성 문제를 해결합니다. 

​    특히, Redis의 WATCH 및 MULTI/EXEC 명령어를 사용해 낙관적 잠금을 구현할 수 있습니다.



**■ 방안** **4:** **이벤트** **소싱****(Event Sourcing)**



  **1.** **이벤트 기반 예약 처리**

   \- 예약 요청을 이벤트로 처리하여, 예약이 완료될 때까지의 모든 상태 변화를 이벤트로 기록합니다.

   \- 이벤트 소싱을 사용하면 모든 이벤트를 재생하여 시스템의 현재 상태를 복원할 수 있으며, 동시성 문제 발생 시 롤백 또는 재 처리할 수 있습니다.



  **2. Saga** **패턴**

   \- 분산 트랜잭션을 관리하기 위해 Saga 패턴을 도입하여, 각 트랜잭션 단계를 독립적으로 관리하고, 실패 시 롤백 작업을 정의합니다.



**4.** **프로세스 설계**



  예약 요청 프로세스(Optimistic Locking 사용 예시)

  Step 1: 예약 요청 수신 

​     → 사용자가 예약 요청을 서버로 보냅니다.

  Step 2: 데이터베이스에서 레코드 조회

​     → 예약하려는 인벤토리의 현재 상태 및 version을 조회합니다.

  Step 3: 예약 처리

​     → 비동기적으로 예약을 처리하며, version 필드가 현재 상태와 일치하는지 확인합니다.

​       일치하지 않으면 실패 메시지를 반환하고, 클라이언트는 다시 시도할 수 있습니다.

  Step 4: 성공 시 예약 확정

​     → version 필드를 증가시키고, 인벤토리 상태를 업데이트한 후, 예약을 확정합니다.

  Step 5: 클라이언트에 응답 반환

​     → 예약 성공 또는 실패 여부를 클라이언트에 반환합니다.

![image-20240811231933094](C:\Users\redmars\AppData\Roaming\Typora\typora-user-images\image-20240811231933094.png)

============================================================================================================================

**■ 문제 정의 및 분석**

  다수의 사용자가 동시에 하나의 인벤토리를 예약하려고 할 때, 데이터 모델에서 발생할 수 있는 주요 문제는 다음과 같습니다



 **1.** **레이스 컨디션** **(Race Condition)**

   여러 사용자가 동시에 동일한 인벤토리 아이템을 예약하려고 할 때, 데이터베이스에서 동일한 자원을 동시에 수정하려는 시도로 인해 데이터 일관성이 깨질 수 있습니다. 

   예를 들어, 동일한 좌석이나 상품이 두 명 이상의 사용자에게 동시에 예약되는 경우가 발생할 수 있습니다.

  **2.** **데이터** **무결성** **손상**

   동시에 여러 요청이 처리될 때, 인벤토리의 가용 수량이 정확하게 관리되지 않을 수 있습니다. 결과적으로, 실제로는 가용하지 않은 자원을 예약하는 상황이 발생할 수 있습니다.

  **3.** **비효율적인** **비동기** **처리**

   비동기 방식으로 예약 프로세스를 처리할 때, 데이터 무결성을 유지하면서 효율적으로 인벤토리를 관리하는 것이 어려울 수 있습니다.



**■ 해결 방안**

  이를 해결하기 위해 데이터 모델과 비동기 예약 처리 프로세스에 다음과 같은 방안을 제시합니다:



  **1.** **데이터 모델 개선**

​    **a)** **예약 상태 및 잠금 필드 추가**

​     \- 잠금 상태 필드 (lock_status) 추가 

​       . 인벤토리 테이블에 lock_status 필드를 추가하여, 해당 인벤토리가 현재 예약 처리 중인지 여부를

​        나타냅니다.

​       . 이 필드는 예약 처리 중인 인벤토리를 잠그는 역할을 하며, 다른 사용자가 해당 인벤토리를 동시에

​        예약하지 못하도록 합니다.

​     \- 예약 상태 필드 (reservation_status) 추가

​       . 예약 테이블에 reservation_status 필드를 추가하여, 예약 요청이 성공적으로 완료되었는지 여부를

​        기록합니다.

​       . 가능한 상태값: PENDING, CONFIRMED, FAILED